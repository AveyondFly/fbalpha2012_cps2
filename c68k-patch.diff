diff --git a/makefile.libretro b/makefile.libretro
index 1b33212..56f0576 100644
--- a/makefile.libretro
+++ b/makefile.libretro
@@ -157,6 +157,7 @@ BURN_BLACKLIST := $(FBA_BURNER_DIR)/un7z.cpp \
 	$(FBA_CPU_DIR)/konami/konamtbl.c \
 	$(FBA_CPU_DIR)/konami/konamops.c \
 	$(FBA_CPU_DIR)/m68k/m68k_in.c \
+	$(FBA_CPU_DIR)/m68k/m68kfpu.c \
 	$(FBA_CPU_DIR)/m6800/6800ops.c \
 	$(FBA_CPU_DIR)/m6800/6800tbl.c \
 	$(FBA_CPU_DIR)/m6805/6805ops.c \
@@ -175,8 +176,6 @@ BURN_BLACKLIST := $(FBA_BURNER_DIR)/un7z.cpp \
 	$(FBA_BURNER_DIR)/cong.cpp \
 	$(FBA_BURNER_DIR)/image.cpp \
 	$(FBA_BURNER_DIR)/misc.cpp \
-	$(FBA_CPU_DIR)/c68k/c68k_ini.c \
-	$(FBA_CPU_DIR)/c68k/c68k_op.c \
 	$(FBA_CPU_DIR)/h6280/tblh6280.c \
 	$(FBA_CPU_DIR)/m6502/t65sc02.c \
 	$(FBA_CPU_DIR)/m6502/t65c02.c \
@@ -188,22 +187,30 @@ BURN_BLACKLIST := $(FBA_BURNER_DIR)/un7z.cpp \
 	$(FBA_CPU_DIR)/nec/necinstr.c \
 	$(FBA_BURN_DIR)/drv/capcom/ctv_make.cpp
 
-EMU_C68K = 0
+EMU_M68K = 1
+EMU_C68K = 1
 FBA_DEFINES :=
+M68K_DIR    :=
 
 ifeq ($(EMU_C68K), 1)
-	FBA_DEFINES += -DEMU_C68K
+	FBA_DEFINES += -DBUILD_C68K
+	BURN_BLACKLIST += $(FBA_CPU_DIR)/c68k/c68k_ini.c \
+							$(FBA_CPU_DIR)/c68k/c68k_op.c
+	M68K_DIR += $(FBA_CPU_DIR)/c68k
+else
+	BURN_BLACKLIST += $(FBA_CPU_DIR)/c68k/c68k.c
+endif
+
+ifeq ($(EMU_M68K), 1)
+	FBA_DEFINES += -DBUILD_M68K
+	M68K_DIR += $(FBA_CPU_DIR)/m68k
+else
 	BURN_BLACKLIST += $(FBA_CPU_DIR)/m68k/m68kcpu.c \
 							$(FBA_CPU_DIR)/m68k/m68kopnz.c \
 							$(FBA_CPU_DIR)/m68k/m68kopac.c \
 							$(FBA_CPU_DIR)/m68k/m68kopdm.c \
 							$(FBA_CPU_DIR)/m68k/m68kopnz.c \
 							$(FBA_CPU_DIR)/m68k/m68kops.c
-	M68K_DIR := $(FBA_CPU_DIR)/c68k
-else
-	FBA_DEFINES += -DEMU_M68K
-	BURN_BLACKLIST += $(FBA_CPU_DIR)/c68k/c68k.c
-	M68K_DIR := $(FBA_CPU_DIR)/m68k
 endif
 
 #ifeq ($(LIBRETRO_OPTIMIZATIONS), 1)
diff --git a/src/burn/burn.h b/src/burn/burn.h
index f0d9359..38ce29f 100644
--- a/src/burn/burn.h
+++ b/src/burn/burn.h
@@ -535,6 +535,14 @@ void IpsApplyPatches(UINT8* base, char* rom_name);
 #define FBF_SONICWI										(1 << 7)
 #define FBF_PWRINST										(1 << 8)
 
+// ---------------------------------------------------------------------------
+// Common CPU definitions 
+
+#define CPU_IRQSTATUS_NONE	0
+#define CPU_IRQSTATUS_ACK	1
+#define CPU_IRQSTATUS_AUTO	2
+#define CPU_IRQSTATUS_HOLD	4
+
 #ifdef __cplusplus
 } // End of extern "C"
 #endif
diff --git a/src/burner/libretro/libretro.cpp b/src/burner/libretro/libretro.cpp
index 5a4d7d7..1c354a1 100644
--- a/src/burner/libretro/libretro.cpp
+++ b/src/burner/libretro/libretro.cpp
@@ -474,6 +474,14 @@ static void check_variables(void)
    }
 }
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern INT32 nSekCpuCore;
+#ifdef __cplusplus
+}
+#endif
+
 void retro_run(void)
 {
    INT32 width, height;
@@ -482,6 +490,7 @@ void retro_run(void)
 
    poll_input();
 
+   nSekCpuCore = 1;
    nBurnLayer = 0xff;
    pBurnSoundOut = g_audio_buf;
    nBurnSoundRate = AUDIO_SAMPLERATE;
diff --git a/src/cpu/m68000_intf.c b/src/cpu/m68000_intf.c
index 1008f80..4deb0a3 100644
--- a/src/cpu/m68000_intf.c
+++ b/src/cpu/m68000_intf.c
@@ -3,6 +3,9 @@
 #include "m68000_intf.h"
 #include "m68000_debug.h"
 
+INT32 nSekCpuCore = SEK_CORE_C68K;  // 0 - c68k, 1 - m68k, 2 - a68k
+INT32 DebugStep = 0; // 0 - off, 1 - on
+
 #ifdef EMU_M68K
 INT32 nSekM68KContextSize[SEK_MAX];
 INT8* SekM68KContext[SEK_MAX];
@@ -23,13 +26,13 @@ INT32 nSekCPUType[SEK_MAX], nSekCycles[SEK_MAX], nSekIRQPending[SEK_MAX];
 
 #if defined (FBA_DEBUG)
 
-void (*SekDbgBreakpointHandlerRead)(UINT32, INT32);
-void (*SekDbgBreakpointHandlerFetch)(UINT32, INT32);
-void (*SekDbgBreakpointHandlerWrite)(UINT32, INT32);
+void (*SekDbgBreakpointHandlerRead)(UINT32, INT32) = NULL;
+void (*SekDbgBreakpointHandlerFetch)(UINT32, INT32) = NULL;
+void (*SekDbgBreakpointHandlerWrite)(UINT32, INT32) = NULL;
 
-UINT32 (*SekDbgFetchByteDisassembler)(UINT32);
-UINT32 (*SekDbgFetchWordDisassembler)(UINT32);
-UINT32 (*SekDbgFetchLongDisassembler)(UINT32);
+UINT32 (*SekDbgFetchByteDisassembler)(UINT32) = NULL;
+UINT32 (*SekDbgFetchWordDisassembler)(UINT32) = NULL;
+UINT32 (*SekDbgFetchLongDisassembler)(UINT32) = NULL;
 
 static struct { UINT32 address; INT32 id; } BreakpointDataRead[9]  = { { 0, 0 }, };
 static struct { UINT32 address; INT32 id; } BreakpointDataWrite[9] = { { 0, 0 }, };
@@ -141,15 +144,15 @@ inline static void SingleStep_PC()
 // ----------------------------------------------------------------------------
 // Default memory access handlers
 
-UINT8 __fastcall DefReadByte(UINT32 a) { return 0; }
-void __fastcall DefWriteByte(UINT32 a, UINT8 b) { }
+UINT8  DefReadByte(UINT32 a) { return 0; }
+void  DefWriteByte(UINT32 a, UINT8 b) { }
 
 #define DEFWORDHANDLERS(i)																				\
-	UINT16 __fastcall DefReadWord##i(UINT32 a) { SEK_DEF_READ_WORD(i, a) }				\
-	void __fastcall DefWriteWord##i(UINT32 a, UINT16 d) { SEK_DEF_WRITE_WORD(i, a ,d) }
+	UINT16  DefReadWord##i(UINT32 a) { SEK_DEF_READ_WORD(i, a) }				\
+	void  DefWriteWord##i(UINT32 a, UINT16 d) { SEK_DEF_WRITE_WORD(i, a ,d) }
 #define DEFLONGHANDLERS(i)																				\
-	UINT32 __fastcall DefReadLong##i(UINT32 a) { SEK_DEF_READ_LONG(i, a) }					\
-	void __fastcall DefWriteLong##i(UINT32 a, UINT32 d) { SEK_DEF_WRITE_LONG(i, a , d) }
+	UINT32  DefReadLong##i(UINT32 a) { SEK_DEF_READ_LONG(i, a) }					\
+	void  DefWriteLong##i(UINT32 a, UINT32 d) { SEK_DEF_WRITE_LONG(i, a , d) }
 
 DEFWORDHANDLERS(0)
 DEFLONGHANDLERS(0)
@@ -216,10 +219,12 @@ inline static UINT8 ReadByte(UINT32 a)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("read8 0x%08X\n"), a);
-
 	pr = FIND_R(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+#ifdef FBA_DEBUG
+	CheckBreakpoint_R(a, ~0);
+#endif
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		a ^= 1;
 		return pr[a & SEK_PAGEM];
 	}
@@ -232,10 +237,9 @@ inline static UINT8 FetchByte(UINT32 a)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("fetch8 0x%08X\n"), a);
-
 	pr = FIND_F(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		a ^= 1;
 		return pr[a & SEK_PAGEM];
 	}
@@ -248,10 +252,9 @@ inline static void WriteByte(UINT32 a, UINT8 d)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("write8 0x%08X\n"), a);
-
 	pr = FIND_W(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		a ^= 1;
 		pr[a & SEK_PAGEM] = (UINT8)d;
 		return;
@@ -266,7 +269,8 @@ inline static void WriteByteROM(UINT32 a, UINT8 d)
 	a &= 0xFFFFFF;
 
 	pr = FIND_R(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		a ^= 1;
 		pr[a & SEK_PAGEM] = (UINT8)d;
 		return;
@@ -280,12 +284,9 @@ inline static UINT16 ReadWord(UINT32 a)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("read16 0x%08X\n"), a);
-
 	pr = FIND_R(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
 		return BURN_ENDIAN_SWAP_INT16(*((UINT16*)(pr + (a & SEK_PAGEM))));
-	}
 	return pSekExt->ReadWord[(uintptr_t)pr](a);
 }
 
@@ -295,12 +296,9 @@ inline static UINT16 FetchWord(UINT32 a)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("fetch16 0x%08X\n"), a);
-
 	pr = FIND_F(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
 		return BURN_ENDIAN_SWAP_INT16(*((UINT16*)(pr + (a & SEK_PAGEM))));
-	}
 	return pSekExt->ReadWord[(uintptr_t)pr](a);
 }
 
@@ -310,9 +308,10 @@ inline static void WriteWord(UINT32 a, UINT16 d)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("write16 0x%08X\n"), a);
-
 	pr = FIND_W(a);
+#ifdef FBA_DEBUG
+	CheckBreakpoint_W(a, ~1);
+#endif
 	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
 		*((UINT16*)(pr + (a & SEK_PAGEM))) = (UINT16)BURN_ENDIAN_SWAP_INT16(d);
 		return;
@@ -340,10 +339,12 @@ inline static UINT32 ReadLong(UINT32 a)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("read32 0x%08X\n"), a);
-
 	pr = FIND_R(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+#ifdef FBA_DEBUG
+	CheckBreakpoint_R(a, ~1);
+#endif
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		UINT32 r = *((UINT32*)(pr + (a & SEK_PAGEM)));
 		r = (r >> 16) | (r << 16);
 		return BURN_ENDIAN_SWAP_INT32(r);
@@ -357,10 +358,9 @@ inline static UINT32 FetchLong(UINT32 a)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("fetch32 0x%08X\n"), a);
-
 	pr = FIND_F(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		UINT32 r = *((UINT32*)(pr + (a & SEK_PAGEM)));
 		r = (r >> 16) | (r << 16);
 		return BURN_ENDIAN_SWAP_INT32(r);
@@ -374,10 +374,12 @@ inline static void WriteLong(UINT32 a, UINT32 d)
 
 	a &= 0xFFFFFF;
 
-//	bprintf(PRINT_NORMAL, _T("write32 0x%08X\n"), a);
-
 	pr = FIND_W(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+#ifdef FBA_DEBUG
+	CheckBreakpoint_W(a, ~1);
+#endif
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		d = (d >> 16) | (d << 16);
 		*((UINT32*)(pr + (a & SEK_PAGEM))) = BURN_ENDIAN_SWAP_INT32(d);
 		return;
@@ -392,7 +394,8 @@ inline static void WriteLongROM(UINT32 a, UINT32 d)
 	a &= 0xFFFFFF;
 
 	pr = FIND_R(a);
-	if ((uintptr_t)pr >= SEK_MAXHANDLER) {
+	if ((uintptr_t)pr >= SEK_MAXHANDLER)
+   {
 		d = (d >> 16) | (d << 16);
 		*((UINT32*)(pr + (a & SEK_PAGEM))) = d;
 		return;
@@ -403,7 +406,7 @@ inline static void WriteLongROM(UINT32 a, UINT32 d)
 #if defined (FBA_DEBUG)
 
 // Breakpoint checking memory access functions
-UINT8 __fastcall ReadByteBP(UINT32 a)
+UINT8  ReadByteBP(UINT32 a)
 {
 	UINT8* pr;
 
@@ -420,7 +423,7 @@ UINT8 __fastcall ReadByteBP(UINT32 a)
 	return pSekExt->ReadByte[(uintptr_t)pr](a);
 }
 
-void __fastcall WriteByteBP(UINT32 a, UINT8 d)
+void  WriteByteBP(UINT32 a, UINT8 d)
 {
 	UINT8* pr;
 
@@ -438,7 +441,7 @@ void __fastcall WriteByteBP(UINT32 a, UINT8 d)
 	pSekExt->WriteByte[(uintptr_t)pr](a, d);
 }
 
-UINT16 __fastcall ReadWordBP(UINT32 a)
+UINT16  ReadWordBP(UINT32 a)
 {
 	UINT8* pr;
 
@@ -454,7 +457,7 @@ UINT16 __fastcall ReadWordBP(UINT32 a)
 	return pSekExt->ReadWord[(uintptr_t)pr](a);
 }
 
-void __fastcall WriteWordBP(UINT32 a, UINT16 d)
+void  WriteWordBP(UINT32 a, UINT16 d)
 {
 	UINT8* pr;
 
@@ -471,7 +474,7 @@ void __fastcall WriteWordBP(UINT32 a, UINT16 d)
 	pSekExt->WriteWord[(uintptr_t)pr](a, d);
 }
 
-UINT32 __fastcall ReadLongBP(UINT32 a)
+UINT32  ReadLongBP(UINT32 a)
 {
 	UINT8* pr;
 
@@ -489,7 +492,7 @@ UINT32 __fastcall ReadLongBP(UINT32 a)
 	return pSekExt->ReadLong[(uintptr_t)pr](a);
 }
 
-void __fastcall WriteLongBP(UINT32 a, UINT32 d)
+void  WriteLongBP(UINT32 a, UINT32 d)
 {
 	UINT8* pr;
 
@@ -517,19 +520,19 @@ struct A68KContext* SekRegs[SEK_MAX] = { NULL, };
 #endif
 
 struct A68KInter {
-	void (__fastcall *DebugCallback) ();
-	UINT8  (__fastcall *Read8) (UINT32 a);
-	UINT16 (__fastcall *Read16)(UINT32 a);
-	UINT32   (__fastcall *Read32)(UINT32 a);
-	void (__fastcall *Write8)  (UINT32 a, UINT8 d);
-	void (__fastcall *Write16) (UINT32 a, UINT16 d);
-	void (__fastcall *Write32) (UINT32 a, UINT32 d);
-	void (__fastcall *ChangePc)(UINT32 a);
-	UINT8  (__fastcall *PcRel8) (UINT32 a);
-	UINT16 (__fastcall *PcRel16)(UINT32 a);
-	UINT32   (__fastcall *PcRel32)(UINT32 a);
-	UINT16 (__fastcall *Dir16)(UINT32 a);
-	UINT32   (__fastcall *Dir32)(UINT32 a);
+	void ( *DebugCallback) ();
+	UINT8  ( *Read8) (UINT32 a);
+	UINT16 ( *Read16)(UINT32 a);
+	UINT32   ( *Read32)(UINT32 a);
+	void ( *Write8)  (UINT32 a, UINT8 d);
+	void ( *Write16) (UINT32 a, UINT16 d);
+	void ( *Write32) (UINT32 a, UINT32 d);
+	void ( *ChangePc)(UINT32 a);
+	UINT8  ( *PcRel8) (UINT32 a);
+	UINT16 ( *PcRel16)(UINT32 a);
+	UINT32   ( *PcRel32)(UINT32 a);
+	UINT16 ( *Dir16)(UINT32 a);
+	UINT32   ( *Dir32)(UINT32 a);
 };
 
 #ifdef EMU_A68K
@@ -547,23 +550,23 @@ struct A68KInter {
 
  struct A68KInter a68k_memory_intf;
 
-UINT8  __fastcall A68KRead8 (UINT32 a) { return ReadByte(a);}
-UINT16 __fastcall A68KRead16(UINT32 a) { return ReadWord(a);}
-UINT32   __fastcall A68KRead32(UINT32 a) { return ReadLong(a);}
-UINT8  __fastcall A68KFetch8 (UINT32 a) { return FetchByte(a);}
-UINT16 __fastcall A68KFetch16(UINT32 a) { return FetchWord(a);}
-UINT32   __fastcall A68KFetch32(UINT32 a) { return FetchLong(a);}
-void __fastcall A68KWrite8 (UINT32 a,UINT8 d)  { WriteByte(a,d);}
-void __fastcall A68KWrite16(UINT32 a,UINT16 d) { WriteWord(a,d);}
-void __fastcall A68KWrite32(UINT32 a,UINT32 d)   { WriteLong(a,d);}
+UINT8   A68KRead8 (UINT32 a) { return ReadByte(a);}
+UINT16  A68KRead16(UINT32 a) { return ReadWord(a);}
+UINT32    A68KRead32(UINT32 a) { return ReadLong(a);}
+UINT8   A68KFetch8 (UINT32 a) { return FetchByte(a);}
+UINT16  A68KFetch16(UINT32 a) { return FetchWord(a);}
+UINT32    A68KFetch32(UINT32 a) { return FetchLong(a);}
+void  A68KWrite8 (UINT32 a,UINT8 d)  { WriteByte(a,d);}
+void  A68KWrite16(UINT32 a,UINT16 d) { WriteWord(a,d);}
+void  A68KWrite32(UINT32 a,UINT32 d)   { WriteLong(a,d);}
 
 #if defined (FBA_DEBUG)
-void __fastcall A68KCheckBreakpoint() { CheckBreakpoint_PC(); }
-void __fastcall A68KSingleStep() { SingleStep_PC(); }
+void  A68KCheckBreakpoint() { CheckBreakpoint_PC(); }
+void  A68KSingleStep() { SingleStep_PC(); }
 #endif
 
 #ifdef EMU_A68K
-void __fastcall A68KChangePC(UINT32 pc)
+void  A68KChangePC(UINT32 pc)
 {
 	pc &= 0xFFFFFF;
 
@@ -576,38 +579,38 @@ void __fastcall A68KChangePC(UINT32 pc)
 #endif
 
 #ifdef EMU_M68K
-unsigned int __fastcall M68KReadByte(unsigned int a) { return (unsigned int)ReadByte(a); }
-unsigned int __fastcall M68KReadWord(unsigned int a) { return (unsigned int)ReadWord(a); }
-unsigned int __fastcall M68KReadLong(unsigned int a) { return               ReadLong(a); }
+unsigned int  M68KReadByte(unsigned int a) { return (unsigned int)ReadByte(a); }
+unsigned int  M68KReadWord(unsigned int a) { return (unsigned int)ReadWord(a); }
+unsigned int  M68KReadLong(unsigned int a) { return               ReadLong(a); }
 
-unsigned int __fastcall M68KFetchByte(unsigned int a) { return (unsigned int)FetchByte(a); }
-unsigned int __fastcall M68KFetchWord(unsigned int a) { return (unsigned int)FetchWord(a); }
-unsigned int __fastcall M68KFetchLong(unsigned int a) { return               FetchLong(a); }
+unsigned int  M68KFetchByte(unsigned int a) { return (unsigned int)FetchByte(a); }
+unsigned int  M68KFetchWord(unsigned int a) { return (unsigned int)FetchWord(a); }
+unsigned int  M68KFetchLong(unsigned int a) { return               FetchLong(a); }
 
 #ifdef FBA_DEBUG
-UINT32 __fastcall M68KReadByteBP(UINT32 a) { return (UINT32)ReadByteBP(a); }
-UINT32 __fastcall M68KReadWordBP(UINT32 a) { return (UINT32)ReadWordBP(a); }
-UINT32 __fastcall M68KReadLongBP(UINT32 a) { return               ReadLongBP(a); }
+UINT32  M68KReadByteBP(UINT32 a) { return (UINT32)ReadByteBP(a); }
+UINT32  M68KReadWordBP(UINT32 a) { return (UINT32)ReadWordBP(a); }
+UINT32  M68KReadLongBP(UINT32 a) { return               ReadLongBP(a); }
 
-void __fastcall M68KWriteByteBP(UINT32 a, UINT32 d) { WriteByteBP(a, d); }
-void __fastcall M68KWriteWordBP(UINT32 a, UINT32 d) { WriteWordBP(a, d); }
-void __fastcall M68KWriteLongBP(UINT32 a, UINT32 d) { WriteLongBP(a, d); }
+void  M68KWriteByteBP(UINT32 a, UINT32 d) { WriteByteBP(a, d); }
+void  M68KWriteWordBP(UINT32 a, UINT32 d) { WriteWordBP(a, d); }
+void  M68KWriteLongBP(UINT32 a, UINT32 d) { WriteLongBP(a, d); }
 
 void M68KCheckBreakpoint() { CheckBreakpoint_PC(); }
 void M68KSingleStep() { SingleStep_PC(); }
 
-UINT32 (__fastcall *M68KReadByteDebug)(UINT32);
-UINT32 (__fastcall *M68KReadWordDebug)(UINT32);
-UINT32 (__fastcall *M68KReadLongDebug)(UINT32);
+UINT32 (*M68KReadByteDebug)(UINT32);
+UINT32 (*M68KReadWordDebug)(UINT32);
+UINT32 (*M68KReadLongDebug)(UINT32);
 
-void (__fastcall *M68KWriteByteDebug)(UINT32, UINT32);
-void (__fastcall *M68KWriteWordDebug)(UINT32, UINT32);
-void (__fastcall *M68KWriteLongDebug)(UINT32, UINT32);
+void ( *M68KWriteByteDebug)(UINT32, UINT32);
+void ( *M68KWriteWordDebug)(UINT32, UINT32);
+void ( *M68KWriteLongDebug)(UINT32, UINT32);
 #endif
 
-void __fastcall M68KWriteByte(unsigned int a, unsigned int d) { WriteByte(a, d); }
-void __fastcall M68KWriteWord(unsigned int a, unsigned int d) { WriteWord(a, d); }
-void __fastcall M68KWriteLong(unsigned int a, unsigned int d) { WriteLong(a, d); }
+void  M68KWriteByte(unsigned int a, unsigned int d) { WriteByte(a, d); }
+void  M68KWriteWord(unsigned int a, unsigned int d) { WriteWord(a, d); }
+void  M68KWriteLong(unsigned int a, unsigned int d) { WriteLong(a, d); }
 #endif
 
 #ifdef EMU_C68K
@@ -620,7 +623,6 @@ void C68KWriteWord(UINT32 a, UINT16 d) { WriteWord(a, d); }
 
 UINT32 C68KRebasePC(UINT32 pc)
 {
-   //	bprintf(PRINT_NORMAL, _T("C68KRebasePC 0x%08x\n"), pc);
    pc &= 0xFFFFFF;
    SekC68KCurrentContext->BasePC = (UINT32)FIND_F(pc) - (pc & ~SEK_PAGEM);
    return SekC68KCurrentContext->BasePC + pc;
@@ -628,7 +630,7 @@ UINT32 C68KRebasePC(UINT32 pc)
 
 INT32 C68KInterruptCallBack(INT32 irqline)
 {
-   if (nSekIRQPending[nSekActive] & (SEK_IRQSTATUS_AUTO << 12))
+   if (nSekIRQPending[nSekActive] & (CPU_IRQSTATUS_AUTO << 12))
    {
       SekC68KContext[nSekActive]->IRQState = 0;	//CLEAR_LINE
       SekC68KContext[nSekActive]->IRQLine = 0;
@@ -714,41 +716,38 @@ void SekWriteLongROM(UINT32 a, UINT32 d) { WriteLongROM(a, d); }
 #ifdef EMU_A68K
 static INT32 A68KIRQAcknowledge(INT32 nIRQ)
 {
-	if (nSekIRQPending[nSekActive] & SEK_IRQSTATUS_AUTO) {
+   if (nSekIRQPending[nSekActive] & (CPU_IRQSTATUS_AUTO << 12))
+   {
 		M68000_regs.irq &= 0x78;
 		nSekIRQPending[nSekActive] = 0;
 	}
 
 	nSekIRQPending[nSekActive] = 0;
 	
-	if (pSekExt->IrqCallback) {
+	if (pSekExt->IrqCallback)
 		return pSekExt->IrqCallback(nIRQ);
-	}
 
 	return -1;
 }
 
 static INT32 A68KResetCallback()
 {
-	if (pSekExt->ResetCallback == NULL) {
+	if (pSekExt->ResetCallback == NULL)
 		return 0;
-	}
 	return pSekExt->ResetCallback();
 }
 
 static INT32 A68KRTECallback()
 {
-	if (pSekExt->RTECallback == NULL) {
+	if (pSekExt->RTECallback == NULL)
 		return 0;
-	}
 	return pSekExt->RTECallback();
 }
 
 static INT32 A68KCmpCallback(UINT32 val, INT32 reg)
 {
-	if (pSekExt->CmpCallback == NULL) {
+	if (pSekExt->CmpCallback == NULL)
 		return 0;
-	}
 	return pSekExt->CmpCallback(val, reg);
 }
 
@@ -769,14 +768,14 @@ static INT32 SekSetup(struct A68KContext* psr)
 #ifdef EMU_M68K
 int M68KIRQAcknowledge(int nIRQ)
 {
-	if (nSekIRQPending[nSekActive] & SEK_IRQSTATUS_AUTO) {
+	if (nSekIRQPending[nSekActive] & (CPU_IRQSTATUS_AUTO << 12))
+   {
 		m68k_set_irq(0);
 		nSekIRQPending[nSekActive] = 0;
 	}
 	
-	if (pSekExt->IrqCallback) {
+	if (pSekExt->IrqCallback)
 		return pSekExt->IrqCallback(nIRQ);
-	}
 
 	return M68K_INT_ACK_AUTOVECTOR;
 }
@@ -807,17 +806,15 @@ void M68KcmpildCallback(unsigned int val, int reg)
 #ifdef EMU_A68K
 static INT32 SekInitCPUA68K(INT32 nCount, INT32 nCPUType)
 {
-	if (nCPUType != 0x68000) {
+	if (nCPUType != 0x68000)
 		return 1;
-	}
 
 	nSekCPUType[nCount] = 0;
 
 	// Allocate emu-specific cpu states
 	SekRegs[nCount] = (struct A68KContext*)malloc(sizeof(struct A68KContext));
-	if (SekRegs[nCount] == NULL) {
+	if (SekRegs[nCount] == NULL)
 		return 1;
-	}
 
 	// Setup each cpu context
 	memset(SekRegs[nCount], 0, sizeof(struct A68KContext));
@@ -835,25 +832,25 @@ static INT32 SekInitCPUM68K(INT32 nCount, INT32 nCPUType)
 {
 	nSekCPUType[nCount] = nCPUType;
 
-	switch (nCPUType) {
-		case 0x68000:
-			m68k_set_cpu_type(M68K_CPU_TYPE_68000);
-			break;
-		case 0x68010:
-			m68k_set_cpu_type(M68K_CPU_TYPE_68010);
-			break;
-		case 0x68EC020:
-			m68k_set_cpu_type(M68K_CPU_TYPE_68EC020);
-			break;
-		default:
-			return 1;
-	}
+	switch (nCPUType)
+   {
+      case 0x68000:
+         m68k_set_cpu_type(M68K_CPU_TYPE_68000);
+         break;
+      case 0x68010:
+         m68k_set_cpu_type(M68K_CPU_TYPE_68010);
+         break;
+      case 0x68EC020:
+         m68k_set_cpu_type(M68K_CPU_TYPE_68EC020);
+         break;
+      default:
+         return 1;
+   }
 
 	nSekM68KContextSize[nCount] = m68k_context_size();
 	SekM68KContext[nCount] = (INT8*)malloc(nSekM68KContextSize[nCount]);
-	if (SekM68KContext[nCount] == NULL) {
+	if (SekM68KContext[nCount] == NULL)
 		return 1;
-	}
 	memset(SekM68KContext[nCount], 0, nSekM68KContextSize[nCount]);
 	m68k_get_context(SekM68KContext[nCount]);
 
@@ -926,10 +923,6 @@ INT32 SekInit(INT32 nCount, INT32 nCPUType)
 {
 	struct SekExt* ps = NULL;
 
-#if !defined BUILD_A68K
-	bBurnUseASMCPUEmulation = FALSE;
-#endif
-
 	if (nSekActive >= 0)
    {
 		SekClose();
@@ -939,9 +932,13 @@ INT32 SekInit(INT32 nCount, INT32 nCPUType)
 	if (nCount > nSekCount)
 		nSekCount = nCount;
 
+	// only m68k supports 68010 and 68EC020
+	if(nCount == 0 && nCPUType != 0x68000 && nSekCpuCore != SEK_CORE_M68K) nSekCpuCore = SEK_CORE_M68K;
+
 	// Allocate cpu extenal data (memory map etc)
 	SekExt[nCount] = (struct SekExt*)malloc(sizeof(struct SekExt));
-	if (SekExt[nCount] == NULL) {
+	if (SekExt[nCount] == NULL)
+   {
 		SekExit();
 		return 1;
 	}
@@ -1035,42 +1032,55 @@ INT32 SekInit(INT32 nCount, INT32 nCPUType)
 	// Map the normal memory handlers
 	SekDbgDisableBreakpoints();
 
+#ifdef FBA_DEBUG
+	SekDbgFetchByteDisassembler = &SekFetchByte;
+	SekDbgFetchWordDisassembler = &SekFetchWord;
+	SekDbgFetchLongDisassembler = &SekFetchLong;
+#endif
+
 #ifdef EMU_A68K
-	if (bBurnUseASMCPUEmulation && nCPUType == 0x68000) {
-		if (SekInitCPUA68K(nCount, nCPUType)) {
-			SekExit();
-			return 1;
-		}
-	}
-   else
+	if(nSekCpuCore == SEK_CORE_A68K)
    {
+      if (nCPUType == 0x68000)
+      {
+         if (SekInitCPUA68K(nCount, nCPUType))
+         {
+            SekExit();
+            return 1;
+         }
+      }
+   }
 #endif
 
-#if defined(EMU_M68K)
-		m68k_init();
-		if (SekInitCPUM68K(nCount, nCPUType))
+#ifdef EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K)
+   {
+      m68k_init();
+      if (SekInitCPUM68K(nCount, nCPUType))
       {
-			SekExit();
-			return 1;
-		}
-#elif defined(EMU_C68K)
+         SekExit();
+         return 1;
+      }
+   }
+#endif
+
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K)
+   {
       if(SekInitCPUC68K(nCount, nCPUType))
       {
          SekExit();
          return 1;
       }
       C68k_Init( SekC68KCurrentContext );
+   }
 #endif
 
-#ifdef EMU_A68K
-	}
-#endif
-
-	nSekCycles[nCount] = 0;
+	nSekCycles[nCount]     = 0;
 	nSekIRQPending[nCount] = 0;
 
-	nSekCyclesTotal = 0;
-	nSekCyclesScanline = 0;
+	nSekCyclesTotal        = 0;
+	nSekCyclesScanline     = 0;
 
 	CpuCheatRegister(nCount, &SekCheatCpuConfig);
 
@@ -1080,20 +1090,16 @@ INT32 SekInit(INT32 nCount, INT32 nCPUType)
 #ifdef EMU_A68K
 static void SekCPUExitA68K(INT32 i)
 {
-	if (SekRegs[i]) {
-		free(SekRegs[i]);
-		SekRegs[i] = NULL;
-	}
+   free(SekRegs[i]);
+   SekRegs[i] = NULL;
 }
 #endif
 
 #ifdef EMU_M68K
 static void SekCPUExitM68K(INT32 i)
 {
-		if(SekM68KContext[i]) {
-			free(SekM68KContext[i]);
-			SekM68KContext[i] = NULL;
-		}
+   free(SekM68KContext[i]);
+   SekM68KContext[i] = NULL;
 }
 #endif
 
@@ -1105,33 +1111,31 @@ static void SekCPUExitC68K(INT32 i)
 }
 #endif
 
-INT32 SekExit()
+INT32 SekExit(void)
 {
+   INT32 i;
 	// Deallocate cpu extenal data (memory map etc)
-	for (INT32 i = 0; i <= nSekCount; i++) {
-
+	for (i = 0; i <= nSekCount; i++)
+   {
 #ifdef EMU_A68K
-		SekCPUExitA68K(i);
+		if(nSekCpuCore == SEK_CORE_A68K) SekCPUExitA68K(i);
 #endif
 
 #ifdef EMU_M68K
-		SekCPUExitM68K(i);
+		if(nSekCpuCore == SEK_CORE_M68K) SekCPUExitM68K(i);
 #endif
 
 #ifdef EMU_C68K
-		SekCPUExitC68K(i);
+		if(nSekCpuCore == SEK_CORE_C68K) SekCPUExitC68K(i);
 #endif
 
-		// Deallocate other context data
-		if (SekExt[i]) {
-			free(SekExt[i]);
-			SekExt[i] = NULL;
-		}
+		/* Deallocate other context data */
+      free(SekExt[i]);
+      SekExt[i] = NULL;
 	}
 #ifdef EMU_C68K
-   C68k_Exit();
+	if(nSekCpuCore == SEK_CORE_C68K) C68k_Exit();
 #endif
-
 	pSekExt = NULL;
 
 	nSekActive = -1;
@@ -1140,34 +1144,31 @@ INT32 SekExit()
 	return 0;
 }
 
-void SekReset()
+void SekReset(void)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekReset called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekReset called when no CPU open\n"));
-#endif
-
 #ifdef EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
+	if(nSekCpuCore == SEK_CORE_A68K)
+   {
 		// A68K has no internal support for resetting the processor, so do what's needed ourselves
 		M68000_regs.a[7] = FetchLong(0);	// Get initial stackpointer (register A7)
 		M68000_regs.pc = FetchLong(4);		// Get initial PC
 		M68000_regs.srh = 0x27;				// start in supervisor state
 		A68KChangePC(M68000_regs.pc);
-	} else {
+	}
 #endif
 
-#if defined(EMU_M68K)
-		m68k_pulse_reset();
-#elif defined(EMU_C68K)
-      C68k_Reset( SekC68KCurrentContext );
+#ifdef EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K) m68k_pulse_reset();
 #endif
 
-
-#ifdef EMU_A68K
-	}
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K) C68k_Reset( SekC68KCurrentContext );
 #endif
 
+#ifdef FBA_DEBUG
+	if(DebugStep)
+		SekDbgEnableSingleStep();
+#endif
 }
 
 // ----------------------------------------------------------------------------
@@ -1176,35 +1177,26 @@ void SekReset()
 // Open a CPU
 void SekOpen(const INT32 i)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekOpen called without init\n"));
-	if (i > nSekCount) bprintf(PRINT_ERROR, _T("SekOpen called with invalid index %x\n"), i);
-	if (nSekActive != -1) bprintf(PRINT_ERROR, _T("SekOpen called when CPU already open with index %x\n"), i);
-#endif
-
-	if (i != nSekActive) {
+	if (i != nSekActive)
+   {
 		nSekActive = i;
 
-		pSekExt = SekExt[nSekActive];						// Point to cpu context
+		pSekExt = SekExt[nSekActive];						/* Point to cpu context */
 
 #ifdef EMU_A68K
-		if (nSekCPUType[nSekActive] == 0)
+		if(nSekCpuCore == SEK_CORE_A68K)
       {
 			memcpy(&M68000_regs, SekRegs[nSekActive], sizeof(M68000_regs));
 			A68KChangePC(M68000_regs.pc);
 		}
-      else
-      {
 #endif
 
-#if defined(EMU_M68K)
-			m68k_set_context(SekM68KContext[nSekActive]);
-#elif defined(EMU_C68K)
-         SekC68KCurrentContext = SekC68KContext[nSekActive];
+#ifdef EMU_M68K
+		if(nSekCpuCore == SEK_CORE_M68K) m68k_set_context(SekM68KContext[nSekActive]);
 #endif
 
-#ifdef EMU_A68K
-		}
+#ifdef EMU_C68K
+		if(nSekCpuCore == SEK_CORE_C68K) SekC68KCurrentContext = SekC68KContext[nSekActive];
 #endif
 
 		nSekCyclesTotal = nSekCycles[nSekActive];
@@ -1212,20 +1204,15 @@ void SekOpen(const INT32 i)
 }
 
 // Close the active cpu
-void SekClose()
+void SekClose(void)
 {
 #ifdef EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
-		memcpy(SekRegs[nSekActive], &M68000_regs, sizeof(M68000_regs));
-	} else {
+   if(nSekCpuCore == SEK_CORE_A68K)
+      memcpy(SekRegs[nSekActive], &M68000_regs, sizeof(M68000_regs));
 #endif
 
 #ifdef EMU_M68K
-		m68k_get_context(SekM68KContext[nSekActive]);
-#endif
-
-#ifdef EMU_A68K
-	}
+	if(nSekCpuCore == SEK_CORE_M68K) m68k_get_context(SekM68KContext[nSekActive]);
 #endif
 
 	nSekCycles[nSekActive] = nSekCyclesTotal;
@@ -1234,38 +1221,42 @@ void SekClose()
 }
 
 // Get the current CPU
-INT32 SekGetActive()
+INT32 SekGetActive(void)
 {
 	return nSekActive;
 }
 
 // Set the status of an IRQ line on the active CPU
-void SekSetIRQLine(const INT32 line, const INT32 status)
+void SekSetIRQLine(const INT32 line, const INT32 nstatus)
 {
+	INT32 status = nstatus << 12; /* needed for compatibility */
 
-	if (status) {
+	if (status)
+   {
 		nSekIRQPending[nSekActive] = line | status;
 
 #ifdef EMU_A68K
-		if (nSekCPUType[nSekActive] == 0) {
+		if(nSekCpuCore == SEK_CORE_A68K)
+      {
 			nSekCyclesTotal += (nSekCyclesToDo - nSekCyclesDone) - m68k_ICount;
 			nSekCyclesDone += (nSekCyclesToDo - nSekCyclesDone) - m68k_ICount;
 
 			M68000_regs.irq = line;
 			m68k_ICount = nSekCyclesToDo = -1;					// Force A68K to exit
-		} else {
+		}
 #endif
 
-#if defined(EMU_M68K)
-         m68k_set_irq(line);
-#elif defined(EMU_C68K)
+#ifdef EMU_M68K
+		if(nSekCpuCore == SEK_CORE_M68K) m68k_set_irq(line);
+#endif
+
+#ifdef EMU_C68K
+		if(nSekCpuCore == SEK_CORE_C68K)
+      {
          SekC68KCurrentContext->IRQState = 1;	//ASSERT_LINE
          SekC68KCurrentContext->IRQLine = line;
          SekC68KCurrentContext->HaltState = 0;
-#endif
-
-#ifdef EMU_A68K
-		}
+      }
 #endif
 
 		return;
@@ -1274,20 +1265,20 @@ void SekSetIRQLine(const INT32 line, const INT32 status)
 	nSekIRQPending[nSekActive] = 0;
 
 #ifdef EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
+	if (nSekCPUType[nSekActive] == 0)
 		M68000_regs.irq &= 0x78;
-	} else {
 #endif
 
-#if defined(EMU_M68K)
-		m68k_set_irq(0);
-#elif defined(EMU_C68K)
-      SekC68KCurrentContext->IRQState = 0;	//CLEAR_LINE
-		SekC68KCurrentContext->IRQLine = 0;
+#ifdef EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K) m68k_set_irq(0);
 #endif
 
-#ifdef EMU_A68K
-	}
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K)
+   {
+      SekC68KCurrentContext->IRQState = 0;	//CLEAR_LINE
+		SekC68KCurrentContext->IRQLine = 0;
+   }
 #endif
 
 }
@@ -1296,25 +1287,36 @@ void SekSetIRQLine(const INT32 line, const INT32 status)
 void SekRunAdjust(const INT32 nCycles)
 {
 #if defined(EMU_A68K) || defined(EMU_M68K)
-	if (nCycles < 0 && m68k_ICount < -nCycles)
+	if(nSekCpuCore == SEK_CORE_A68K || nSekCpuCore == SEK_CORE_M68K)
    {
-		SekRunEnd();
-		return;
+      if (nCycles < 0 && m68k_ICount < -nCycles)
+      {
+         SekRunEnd();
+         return;
+      }
 	}
 #endif
 
 #ifdef EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
+	if(nSekCpuCore == SEK_CORE_A68K)
+   {
 		m68k_ICount += nCycles;
 		nSekCyclesToDo += nCycles;
 		nSekCyclesSegment += nCycles;
-	} else {
+	}
 #endif
 
-#if defined(EMU_M68K)
+#ifdef EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K)
+   {
       nSekCyclesToDo += nCycles;
       m68k_modify_timeslice(nCycles);
-#elif defined(EMU_C68K)
+   }
+#endif
+
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K)
+   {
       if (nCycles < 0 && c68k_ICount < -nCycles)
       {
          SekRunEnd();
@@ -1323,72 +1325,76 @@ void SekRunAdjust(const INT32 nCycles)
       nSekCyclesToDo += nCycles;
       c68k_ICount += nCycles;
       nSekCyclesSegment += nCycles;
+   }
 #endif
-
-#ifdef EMU_A68K
-	}
-#endif
-
 }
 
 // End the active CPU's timeslice
 void SekRunEnd(void)
 {
-
 #ifdef EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
+	if(nSekCpuCore == SEK_CORE_A68K)
+   {
 		nSekCyclesTotal += (nSekCyclesToDo - nSekCyclesDone) - m68k_ICount;
 		nSekCyclesDone += (nSekCyclesToDo - nSekCyclesDone) - m68k_ICount;
 		nSekCyclesSegment = nSekCyclesDone;
-		m68k_ICount = nSekCyclesToDo = -1;						// Force A68K to exit
-	} else {
+		m68k_ICount = nSekCyclesToDo = -1;						/* Force A68K to exit */
+	}
 #endif
 
-#if defined(EMU_M68K)
-		m68k_end_timeslice();
-#elif defined(EMU_C68K)
-      nSekCyclesTotal += (nSekCyclesToDo - nSekCyclesDone) - c68k_ICount;
-      nSekCyclesDone += (nSekCyclesToDo - nSekCyclesDone) - c68k_ICount;
-      nSekCyclesSegment = nSekCyclesDone;
-      nSekCyclesToDo = c68k_ICount = -1;
+#ifdef EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K) m68k_end_timeslice();
 #endif
 
-#ifdef EMU_A68K
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K)
+   {
+		nSekCyclesTotal += (nSekCyclesToDo - nSekCyclesDone) - c68k_ICount;
+		nSekCyclesDone += (nSekCyclesToDo - nSekCyclesDone) - c68k_ICount;
+		nSekCyclesSegment = nSekCyclesDone;
+		nSekCyclesToDo = c68k_ICount = -1;
 	}
 #endif
 
 }
 
-// Run the active CPU
+/* Run the active CPU */
 INT32 SekRun(const INT32 nCycles)
 {
 
 #ifdef EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
+	if(nSekCpuCore == SEK_CORE_A68K)
+   {
 		nSekCyclesDone = 0;
 		nSekCyclesSegment = nCycles;
-		do {
+		do
+      {
 			m68k_ICount = nSekCyclesToDo = nSekCyclesSegment - nSekCyclesDone;
 
-			if (M68000_regs.irq == 0x80) {						// Cpu is in stopped state till interrupt
+			if (M68000_regs.irq == 0x80)
+         {						/* CPU is in stopped state till interrupt */
 				nSekCyclesDone = nSekCyclesSegment;
 				nSekCyclesTotal += nSekCyclesSegment;
-			} else {
+			}
+         else
+         {
 				M68000_RUN();
 				nSekCyclesDone += nSekCyclesToDo - m68k_ICount;
 				nSekCyclesTotal += nSekCyclesToDo - m68k_ICount;
 			}
-		} while (nSekCyclesDone < nSekCyclesSegment);
+		}while (nSekCyclesDone < nSekCyclesSegment);
 
 		nSekCyclesSegment = nSekCyclesDone;
 		nSekCyclesToDo = m68k_ICount = -1;
 		nSekCyclesDone = 0;
 
 		return nSekCyclesSegment;								// Return the number of cycles actually done
-	} else {
+	}
 #endif
 
-#if defined(EMU_M68K)
+#ifdef EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K) 
+   {
 		nSekCyclesToDo = nCycles;
 
 		nSekCyclesSegment = m68k_execute(nCycles);
@@ -1397,29 +1403,32 @@ INT32 SekRun(const INT32 nCycles)
 		nSekCyclesToDo = m68k_ICount = -1;
 
 		return nSekCyclesSegment;
-#elif defined(EMU_C68K)
-      nSekCyclesToDo = nCycles;
+	}
+#endif
+
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K)
+   {
+		nSekCyclesToDo = nCycles;
 		nSekCyclesSegment = C68k_Exec(SekC68KCurrentContext, nCycles);
 		nSekCyclesTotal += nSekCyclesSegment;
 		nSekCyclesToDo = c68k_ICount = -1;
 
 		return nSekCyclesSegment;
-#else
-		return 0;
-#endif
-
-#ifdef EMU_A68K
 	}
 #endif
 
+   return 0;
 }
 
 // ----------------------------------------------------------------------------
 // Breakpoint support
 
-void SekDbgDisableBreakpoints()
+void SekDbgDisableBreakpoints(void)
 {
 #if defined FBA_DEBUG && defined EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K)
+   {
 		m68k_set_instr_hook_callback(NULL);
 
 		M68KReadByteDebug = M68KReadByte;
@@ -1429,10 +1438,11 @@ void SekDbgDisableBreakpoints()
 		M68KWriteByteDebug = M68KWriteByte;
 		M68KWriteWordDebug = M68KWriteWord;
 		M68KWriteLongDebug = M68KWriteLong;
+   }
 #endif
 
 #ifdef EMU_A68K
-	a68k_memory_intf = a68k_inter_normal;
+	if(nSekCpuCore == SEK_CORE_A68K) a68k_memory_intf = a68k_inter_normal;
 #endif
 
 	mame_debug = 0;
@@ -1442,69 +1452,71 @@ void SekDbgDisableBreakpoints()
 
 void SekDbgEnableBreakpoints()
 {
-	if (BreakpointDataRead[0].address || BreakpointDataWrite[0].address || BreakpointFetch[0].address) {
-#if defined FBA_DEBUG && defined EMU_M68K
-		SekDbgDisableBreakpoints();
-
-		if (BreakpointFetch[0].address) {
-			m68k_set_instr_hook_callback(M68KCheckBreakpoint);
-		}
-
-		if (BreakpointDataRead[0].address) {
-			M68KReadByteDebug = M68KReadByteBP;
-			M68KReadWordDebug = M68KReadWordBP;
-			M68KReadLongDebug = M68KReadLongBP;
-		}
+	if (BreakpointDataRead[0].address || BreakpointDataWrite[0].address || BreakpointFetch[0].address)
+   {
+#ifdef EMU_M68K
+		if(nSekCpuCore == SEK_CORE_M68K)
+      {
+			SekDbgDisableBreakpoints();
 
-		if (BreakpointDataWrite[0].address) {
-			M68KWriteByteDebug = M68KWriteByteBP;
-			M68KWriteWordDebug = M68KWriteWordBP;
-			M68KWriteLongDebug = M68KWriteLongBP;
+			if (BreakpointFetch[0].address)
+				m68k_set_instr_hook_callback(M68KCheckBreakpoint);
 		}
 #endif
 
 #ifdef EMU_A68K
-		a68k_memory_intf = a68k_inter_breakpoint;
-		if (BreakpointFetch[0].address) {
-			a68k_memory_intf.DebugCallback = A68KCheckBreakpoint;
-			mame_debug = 255;
-		} else {
-			a68k_memory_intf.DebugCallback = NULL;
-			mame_debug = 0;
+		if(nSekCpuCore == SEK_CORE_A68K)
+      {
+			if (BreakpointFetch[0].address)
+         {
+				a68k_memory_intf.DebugCallback = A68KCheckBreakpoint;
+				mame_debug = 255;
+			}
+         else
+         {
+				a68k_memory_intf.DebugCallback = NULL;
+				mame_debug = 0;
+			}
 		}
 #endif
-	} else {
-		SekDbgDisableBreakpoints();
 	}
+   else
+		SekDbgDisableBreakpoints();
 }
 
-void SekDbgEnableSingleStep()
+void SekDbgEnableSingleStep(void)
 {
 #if defined FBA_DEBUG && defined EMU_M68K
-	m68k_set_instr_hook_callback(M68KSingleStep);
+	if(nSekCpuCore == SEK_CORE_M68K) m68k_set_instr_hook_callback(M68KSingleStep);
 #endif
 
 #ifdef EMU_A68K
-	a68k_memory_intf.DebugCallback = A68KSingleStep;
-	mame_debug = 254;
+   if(nSekCpuCore == SEK_CORE_A68K)
+   {
+      a68k_memory_intf.DebugCallback = A68KSingleStep;
+      mame_debug = 254;
+   }
 #endif
 
 #ifdef EMU_C68K
-   SekC68KCurrentContext->Dbg_CallBack = SingleStep_PC;
+	if(nSekCpuCore == SEK_CORE_C68K)
+		SekC68KCurrentContext->Dbg_CallBack = SingleStep_PC;
 #endif
 }
 
 INT32 SekDbgSetBreakpointDataRead(UINT32 nAddress, INT32 nIdentifier)
 {
-	for (INT32 i = 0; i < 8; i++) {
-		if (BreakpointDataRead[i].id == nIdentifier) {
-
-			if	(nAddress) {							// Change breakpoint
+   INT32 i;
+	for (i = 0; i < 8; i++)
+   {
+		if (BreakpointDataRead[i].id == nIdentifier)
+      {
+			if	(nAddress) /* Change breakpoint */
 				BreakpointDataRead[i].address = nAddress;
-			} else {									// Delete breakpoint
-				for ( ; i < 8; i++) {
+			else /* Delete breakpoint */
+         {
+				for ( ; i < 8; i++)
 					BreakpointDataRead[i] = BreakpointDataRead[i + 1];
-				}
 			}
 
 			SekDbgEnableBreakpoints();
@@ -1512,7 +1524,7 @@ INT32 SekDbgSetBreakpointDataRead(UINT32 nAddress, INT32 nIdentifier)
 		}
 	}
 
-	// No breakpoints present, add it to the 1st slot
+	/* No breakpoints present, add it to the 1st slot */
 	BreakpointDataRead[0].address = nAddress;
 	BreakpointDataRead[0].id = nIdentifier;
 
@@ -1522,28 +1534,30 @@ INT32 SekDbgSetBreakpointDataRead(UINT32 nAddress, INT32 nIdentifier)
 
 INT32 SekDbgSetBreakpointDataWrite(UINT32 nAddress, INT32 nIdentifier)
 {
-	for (INT32 i = 0; i < 8; i++) {
-		if (BreakpointDataWrite[i].id == nIdentifier) {
-
-			if (nAddress) {								// Change breakpoint
-				BreakpointDataWrite[i].address = nAddress;
-			} else {									// Delete breakpoint
-				for ( ; i < 8; i++) {
-					BreakpointDataWrite[i] = BreakpointDataWrite[i + 1];
-				}
-			}
-
-			SekDbgEnableBreakpoints();
-			return 0;
-		}
-	}
+   INT32 i;
+   for (i = 0; i < 8; i++)
+   {
+      if (BreakpointDataWrite[i].id == nIdentifier)
+      {
+         if (nAddress) /* Change breakpoint */
+            BreakpointDataWrite[i].address = nAddress;
+         else
+         { /* Delete breakpoint */
+            for ( ; i < 8; i++)
+               BreakpointDataWrite[i] = BreakpointDataWrite[i + 1];
+         }
+
+         SekDbgEnableBreakpoints();
+         return 0;
+      }
+   }
 
-	// No breakpoints present, add it to the 1st slot
-	BreakpointDataWrite[0].address = nAddress;
-	BreakpointDataWrite[0].id = nIdentifier;
+   /* No breakpoints present, add it to the 1st slot */
+   BreakpointDataWrite[0].address = nAddress;
+   BreakpointDataWrite[0].id = nIdentifier;
 
-	SekDbgEnableBreakpoints();
-	return 0;
+   SekDbgEnableBreakpoints();
+   return 0;
 }
 
 INT32 SekDbgSetBreakpointFetch(UINT32 nAddress, INT32 nIdentifier)
@@ -1580,17 +1594,14 @@ INT32 SekDbgSetBreakpointFetch(UINT32 nAddress, INT32 nIdentifier)
 // Note - each page is 1 << SEK_BITS.
 INT32 SekMapMemory(UINT8* pMemory, UINT32 nStart, UINT32 nEnd, INT32 nType)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekMapMemory called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekMapMemory called when no CPU open\n"));
-#endif
-
 	UINT8* Ptr = pMemory - nStart;
 	UINT8** pMemMap = pSekExt->MemMap + (nStart >> SEK_SHIFT);
 
 	// Special case for ROM banks
-	if (nType == SM_ROM) {
-		for (UINT32 i = (nStart & ~SEK_PAGEM); i <= nEnd; i += SEK_PAGE_SIZE, pMemMap++) {
+	if (nType == SM_ROM)
+   {
+		for (UINT32 i = (nStart & ~SEK_PAGEM); i <= nEnd; i += SEK_PAGE_SIZE, pMemMap++)
+      {
 			pMemMap[0]			  = Ptr + i;
 			pMemMap[SEK_WADD * 2] = Ptr + i;
 		}
@@ -1616,11 +1627,6 @@ INT32 SekMapMemory(UINT8* pMemory, UINT32 nStart, UINT32 nEnd, INT32 nType)
 
 INT32 SekMapHandler(uintptr_t nHandler, UINT32 nStart, UINT32 nEnd, INT32 nType)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekMapHander called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekMapHandler called when no CPU open\n"));
-#endif
-
 	UINT8** pMemMap = pSekExt->MemMap + (nStart >> SEK_SHIFT);
 
 	// Add to memory map
@@ -1643,11 +1649,6 @@ INT32 SekMapHandler(uintptr_t nHandler, UINT32 nStart, UINT32 nEnd, INT32 nType)
 // Set callbacks
 INT32 SekSetResetCallback(pSekResetCallback pCallback)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetResetCallback called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetResetCallback called when no CPU open\n"));
-#endif
-
 	pSekExt->ResetCallback = pCallback;
 
 	return 0;
@@ -1655,11 +1656,6 @@ INT32 SekSetResetCallback(pSekResetCallback pCallback)
 
 INT32 SekSetRTECallback(pSekRTECallback pCallback)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetRTECallback called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetRTECallback called when no CPU open\n"));
-#endif
-
 	pSekExt->RTECallback = pCallback;
 
 	return 0;
@@ -1667,11 +1663,6 @@ INT32 SekSetRTECallback(pSekRTECallback pCallback)
 
 INT32 SekSetIrqCallback(pSekIrqCallback pCallback)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetIrqCallback called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetIrqCallback called when no CPU open\n"));
-#endif
-
 	pSekExt->IrqCallback = pCallback;
 
 	return 0;
@@ -1679,11 +1670,6 @@ INT32 SekSetIrqCallback(pSekIrqCallback pCallback)
 
 INT32 SekSetCmpCallback(pSekCmpCallback pCallback)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetCmpCallback called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetCmpCallback called when no CPU open\n"));
-#endif
-
 	pSekExt->CmpCallback = pCallback;
 
 	return 0;
@@ -1692,14 +1678,8 @@ INT32 SekSetCmpCallback(pSekCmpCallback pCallback)
 // Set handlers
 INT32 SekSetReadByteHandler(INT32 i, pSekReadByteHandler pHandler)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetReadByteHandler called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetReadByteHandler called when no CPU open\n"));
-#endif
-
-	if (i >= SEK_MAXHANDLER) {
+	if (i >= SEK_MAXHANDLER)
 		return 1;
-	}
 
 	pSekExt->ReadByte[i] = pHandler;
 
@@ -1708,14 +1688,8 @@ INT32 SekSetReadByteHandler(INT32 i, pSekReadByteHandler pHandler)
 
 INT32 SekSetWriteByteHandler(INT32 i, pSekWriteByteHandler pHandler)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetWriteByteHandler called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetWriteByteHandler called when no CPU open\n"));
-#endif
-
-	if (i >= SEK_MAXHANDLER) {
+	if (i >= SEK_MAXHANDLER)
 		return 1;
-	}
 
 	pSekExt->WriteByte[i] = pHandler;
 
@@ -1724,14 +1698,8 @@ INT32 SekSetWriteByteHandler(INT32 i, pSekWriteByteHandler pHandler)
 
 INT32 SekSetReadWordHandler(INT32 i, pSekReadWordHandler pHandler)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetReadWordHandler called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetReadWordHandler called when no CPU open\n"));
-#endif
-
-	if (i >= SEK_MAXHANDLER) {
+	if (i >= SEK_MAXHANDLER)
 		return 1;
-	}
 
 	pSekExt->ReadWord[i] = pHandler;
 
@@ -1740,14 +1708,8 @@ INT32 SekSetReadWordHandler(INT32 i, pSekReadWordHandler pHandler)
 
 INT32 SekSetWriteWordHandler(INT32 i, pSekWriteWordHandler pHandler)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetWriteWordHandler called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetWriteWordHandler called when no CPU open\n"));
-#endif
-
-	if (i >= SEK_MAXHANDLER) {
+	if (i >= SEK_MAXHANDLER)
 		return 1;
-	}
 
 	pSekExt->WriteWord[i] = pHandler;
 
@@ -1756,14 +1718,8 @@ INT32 SekSetWriteWordHandler(INT32 i, pSekWriteWordHandler pHandler)
 
 INT32 SekSetReadLongHandler(INT32 i, pSekReadLongHandler pHandler)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetReadLongHandler called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetReadLongHandler called when no CPU open\n"));
-#endif
-
-	if (i >= SEK_MAXHANDLER) {
+	if (i >= SEK_MAXHANDLER)
 		return 1;
-	}
 
 	pSekExt->ReadLong[i] = pHandler;
 
@@ -1772,14 +1728,8 @@ INT32 SekSetReadLongHandler(INT32 i, pSekReadLongHandler pHandler)
 
 INT32 SekSetWriteLongHandler(INT32 i, pSekWriteLongHandler pHandler)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekSetWriteLongHandler called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekSetWriteLongHandler called when no CPU open\n"));
-#endif
-
-	if (i >= SEK_MAXHANDLER) {
+	if (i >= SEK_MAXHANDLER)
 		return 1;
-	}
 
 	pSekExt->WriteLong[i] = pHandler;
 
@@ -1791,71 +1741,41 @@ INT32 SekSetWriteLongHandler(INT32 i, pSekWriteLongHandler pHandler)
 
 UINT32 SekGetPC(INT32 n)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekGetPC called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekGetPC called when no CPU open\n"));
-#endif
-
 #ifdef EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
-		if (n < 0) {								// Currently active CPU
-		  return M68000_regs.pc;
-		} else {
-			return SekRegs[n]->pc;					// Any CPU
-		}
-	} else {
+	if(nSekCpuCore == SEK_CORE_A68K)
+   {
+		if (n < 0)
+		  return M68000_regs.pc; /* Currently active CPU */
+      else
+         return SekRegs[n]->pc; /* Any CPU */
+	}
 #endif
 
-#if defined(EMU_M68K)
-		return m68k_get_reg(NULL, M68K_REG_PC);
-#elif defined(EMU_C68K)
-      return SekC68KCurrentContext->PC - SekC68KCurrentContext->BasePC;
-#else
-		return 0;
+#ifdef EMU_M68K
+	if(nSekCpuCore == SEK_CORE_M68K) return m68k_get_reg(NULL, M68K_REG_PC);
 #endif
 
-#ifdef EMU_A68K
-	}
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K)  return SekC68KCurrentContext->PC - SekC68KCurrentContext->BasePC;
 #endif
 
+	return 0;
 }
 
-INT32 SekDbgGetCPUType()
+INT32 SekDbgGetCPUType(void)
 {
-#if 0
-	switch (nSekCPUType[nSekActive]) {
-		case 0:
-		case 0x68000:
-			return M68K_CPU_TYPE_68000;
-		case 0x68010:
-			return M68K_CPU_TYPE_68010;
-		case 0x68EC020:
-			return M68K_CPU_TYPE_68EC020;
-	}
-#endif
-
 	return 0;
 }
 
 INT32 SekDbgGetPendingIRQ(void)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekDbgGetPendingIRQ called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekDbgGetPendingIRQ called when no CPU open\n"));
-#endif
-
 	return nSekIRQPending[nSekActive] & 7;
 }
 
 UINT32 SekDbgGetRegister(enum SekRegister nRegister)
 {
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekDbgGetRegister called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekDbgGetRegister called when no CPU open\n"));
-#endif
-
-#if defined EMU_A68K
-	if (nSekCPUType[nSekActive] == 0) {
+#ifdef FBA_DEBUG
+	if(nSekCpuCore == SEK_CORE_A68K) {
 		switch (nRegister) {
 			case SEK_REG_D0:
 				return M68000_regs.d[0];
@@ -1904,216 +1824,152 @@ UINT32 SekDbgGetRegister(enum SekRegister nRegister)
 			case SEK_REG_ISP:
 				return GetA68KISP();
 
+			case SEK_REG_CCR:
+				return M68000_regs.ccr;
 			default:
 				return 0;
 		}
 	}
-#endif
 
-#if defined(EMU_M68K)
-	switch (nRegister)
-   {
-      case SEK_REG_D0:
-         return m68k_get_reg(NULL, M68K_REG_D0);
-      case SEK_REG_D1:
-         return m68k_get_reg(NULL, M68K_REG_D1);
-      case SEK_REG_D2:
-         return m68k_get_reg(NULL, M68K_REG_D2);
-      case SEK_REG_D3:
-         return m68k_get_reg(NULL, M68K_REG_D3);
-      case SEK_REG_D4:
-         return m68k_get_reg(NULL, M68K_REG_D4);
-      case SEK_REG_D5:
-         return m68k_get_reg(NULL, M68K_REG_D5);
-      case SEK_REG_D6:
-         return m68k_get_reg(NULL, M68K_REG_D6);
-      case SEK_REG_D7:
-         return m68k_get_reg(NULL, M68K_REG_D7);
-
-      case SEK_REG_A0:
-         return m68k_get_reg(NULL, M68K_REG_A0);
-      case SEK_REG_A1:
-         return m68k_get_reg(NULL, M68K_REG_A1);
-      case SEK_REG_A2:
-         return m68k_get_reg(NULL, M68K_REG_A2);
-      case SEK_REG_A3:
-         return m68k_get_reg(NULL, M68K_REG_A3);
-      case SEK_REG_A4:
-         return m68k_get_reg(NULL, M68K_REG_A4);
-      case SEK_REG_A5:
-         return m68k_get_reg(NULL, M68K_REG_A5);
-      case SEK_REG_A6:
-         return m68k_get_reg(NULL, M68K_REG_A6);
-      case SEK_REG_A7:
-         return m68k_get_reg(NULL, M68K_REG_A7);
-
-      case SEK_REG_PC:
-         return m68k_get_reg(NULL, M68K_REG_PC);
-
-      case SEK_REG_SR:
-         return m68k_get_reg(NULL, M68K_REG_SR);
-
-      case SEK_REG_SP:
-         return m68k_get_reg(NULL, M68K_REG_SP);
-      case SEK_REG_USP:
-         return m68k_get_reg(NULL, M68K_REG_USP);
-      case SEK_REG_ISP:
-         return m68k_get_reg(NULL, M68K_REG_ISP);
-      case SEK_REG_MSP:
-         return m68k_get_reg(NULL, M68K_REG_MSP);
-
-      case SEK_REG_VBR:
-         return m68k_get_reg(NULL, M68K_REG_VBR);
-
-      case SEK_REG_SFC:
-         return m68k_get_reg(NULL, M68K_REG_SFC);
-      case SEK_REG_DFC:
-         return m68k_get_reg(NULL, M68K_REG_DFC);
-
-      case SEK_REG_CACR:
-         return m68k_get_reg(NULL, M68K_REG_CACR);
-      case SEK_REG_CAAR:
-         return m68k_get_reg(NULL, M68K_REG_CAAR);
+	if(nSekCpuCore == SEK_CORE_M68K) {
+		switch (nRegister) {
+			case SEK_REG_D0:
+				return m68k_get_reg(NULL, M68K_REG_D0);
+			case SEK_REG_D1:
+				return m68k_get_reg(NULL, M68K_REG_D1);
+			case SEK_REG_D2:
+				return m68k_get_reg(NULL, M68K_REG_D2);
+			case SEK_REG_D3:
+				return m68k_get_reg(NULL, M68K_REG_D3);
+			case SEK_REG_D4:
+				return m68k_get_reg(NULL, M68K_REG_D4);
+			case SEK_REG_D5:
+				return m68k_get_reg(NULL, M68K_REG_D5);
+			case SEK_REG_D6:
+				return m68k_get_reg(NULL, M68K_REG_D6);
+			case SEK_REG_D7:
+				return m68k_get_reg(NULL, M68K_REG_D7);
 
-      default:
-         return 0;
-   }
-#elif defined(EMU_C68K)
-   switch (nRegister)
-   {
-      case SEK_REG_D0:
-         return SekC68KCurrentContext->D[0];
-      case SEK_REG_D1:
-         return SekC68KCurrentContext->D[1];
-      case SEK_REG_D2:
-         return SekC68KCurrentContext->D[2];
-      case SEK_REG_D3:
-         return SekC68KCurrentContext->D[3];
-      case SEK_REG_D4:
-         return SekC68KCurrentContext->D[4];
-      case SEK_REG_D5:
-         return SekC68KCurrentContext->D[5];
-      case SEK_REG_D6:
-         return SekC68KCurrentContext->D[6];
-      case SEK_REG_D7:
-         return SekC68KCurrentContext->D[7];
-
-      case SEK_REG_A0:
-         return SekC68KCurrentContext->A[0];
-      case SEK_REG_A1:
-         return SekC68KCurrentContext->A[1];
-      case SEK_REG_A2:
-         return SekC68KCurrentContext->A[2];
-      case SEK_REG_A3:
-         return SekC68KCurrentContext->A[3];
-      case SEK_REG_A4:
-         return SekC68KCurrentContext->A[4];
-      case SEK_REG_A5:
-         return SekC68KCurrentContext->A[5];
-      case SEK_REG_A6:
-         return SekC68KCurrentContext->A[6];
-      case SEK_REG_A7:
-         return SekC68KCurrentContext->A[7];
-
-      case SEK_REG_PC:
-         return SekC68KCurrentContext->PC - SekC68KCurrentContext->BasePC;
-
-      case SEK_REG_SR:
-         return 0;
+			case SEK_REG_A0:
+				return m68k_get_reg(NULL, M68K_REG_A0);
+			case SEK_REG_A1:
+				return m68k_get_reg(NULL, M68K_REG_A1);
+			case SEK_REG_A2:
+				return m68k_get_reg(NULL, M68K_REG_A2);
+			case SEK_REG_A3:
+				return m68k_get_reg(NULL, M68K_REG_A3);
+			case SEK_REG_A4:
+				return m68k_get_reg(NULL, M68K_REG_A4);
+			case SEK_REG_A5:
+				return m68k_get_reg(NULL, M68K_REG_A5);
+			case SEK_REG_A6:
+				return m68k_get_reg(NULL, M68K_REG_A6);
+			case SEK_REG_A7:
+				return m68k_get_reg(NULL, M68K_REG_A7);
 
-      case SEK_REG_SP:
-         return SekC68KCurrentContext->A[7];
-      case SEK_REG_USP:
-         return SekC68KCurrentContext->USP;
-      case SEK_REG_ISP:
-         return 0;
+			case SEK_REG_PC:
+				return m68k_get_reg(NULL, M68K_REG_PC);
 
-#if 0
-      case SEK_REG_CCR:
-         return (SekC68KCurrentContext->flag_X << 4) |
-            (SekC68KCurrentContext->flag_N << 3) |
-            (SekC68KCurrentContext->flag_Z << 2) |
-            (SekC68KCurrentContext->flag_V << 1) |
-            (SekC68KCurrentContext->flag_C << 0);
-#endif
+			case SEK_REG_SR:
+				return m68k_get_reg(NULL, M68K_REG_SR);
 
-      default:
-         return 0;
-   }
-#endif
-}
+			case SEK_REG_SP:
+				return m68k_get_reg(NULL, M68K_REG_SP);
+			case SEK_REG_USP:
+				return m68k_get_reg(NULL, M68K_REG_USP);
+			case SEK_REG_ISP:
+				return m68k_get_reg(NULL, M68K_REG_ISP);
+			case SEK_REG_MSP:
+				return m68k_get_reg(NULL, M68K_REG_MSP);
 
-BOOL SekDbgSetRegister(enum SekRegister nRegister, UINT32 nValue)
-{
-#if 0
-#if defined FBA_DEBUG
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, _T("SekDbgSetRegister called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, _T("SekDbgSetRegister called when no CPU open\n"));
-#endif
-
-	switch (nRegister) {
-		case SEK_REG_D0:
-		case SEK_REG_D1:
-		case SEK_REG_D2:
-		case SEK_REG_D3:
-		case SEK_REG_D4:
-		case SEK_REG_D5:
-		case SEK_REG_D6:
-		case SEK_REG_D7:
-			break;
-
-		case SEK_REG_A0:
-		case SEK_REG_A1:
-		case SEK_REG_A2:
-		case SEK_REG_A3:
-		case SEK_REG_A4:
-		case SEK_REG_A5:
-		case SEK_REG_A6:
-		case SEK_REG_A7:
-			break;
-
-		case SEK_REG_PC:
-			if (nSekCPUType[nSekActive] == 0) {
-#if defined EMU_A68K
-				M68000_regs.pc = nValue;
-				A68KChangePC(M68000_regs.pc);
-#endif
-			} else {
-				m68k_set_reg(M68K_REG_PC, nValue);
-			}
-			SekClose();
-			return TRUE;
+			case SEK_REG_VBR:
+				return m68k_get_reg(NULL, M68K_REG_VBR);
 
-		case SEK_REG_SR:
-			break;
+			case SEK_REG_SFC:
+				return m68k_get_reg(NULL, M68K_REG_SFC);
+			case SEK_REG_DFC:
+				return m68k_get_reg(NULL, M68K_REG_DFC);
 
-		case SEK_REG_SP:
-		case SEK_REG_USP:
-		case SEK_REG_ISP:
-		case SEK_REG_MSP:
-			break;
+			case SEK_REG_CACR:
+				return m68k_get_reg(NULL, M68K_REG_CACR);
+			case SEK_REG_CAAR:
+				return m68k_get_reg(NULL, M68K_REG_CAAR);
 
-		case SEK_REG_VBR:
-			break;
+			default:
+				return 0;
+		}
+	}
 
-		case SEK_REG_SFC:
-		case SEK_REG_DFC:
-			break;
+	if(nSekCpuCore == SEK_CORE_C68K) {
+		switch (nRegister) {
+			case SEK_REG_D0:
+				return SekC68KCurrentContext->D[0];
+			case SEK_REG_D1:
+				return SekC68KCurrentContext->D[1];
+			case SEK_REG_D2:
+				return SekC68KCurrentContext->D[2];
+			case SEK_REG_D3:
+				return SekC68KCurrentContext->D[3];
+			case SEK_REG_D4:
+				return SekC68KCurrentContext->D[4];
+			case SEK_REG_D5:
+				return SekC68KCurrentContext->D[5];
+			case SEK_REG_D6:
+				return SekC68KCurrentContext->D[6];
+			case SEK_REG_D7:
+				return SekC68KCurrentContext->D[7];
 
-		case SEK_REG_CACR:
-		case SEK_REG_CAAR:
-			break;
+			case SEK_REG_A0:
+				return SekC68KCurrentContext->A[0];
+			case SEK_REG_A1:
+				return SekC68KCurrentContext->A[1];
+			case SEK_REG_A2:
+				return SekC68KCurrentContext->A[2];
+			case SEK_REG_A3:
+				return SekC68KCurrentContext->A[3];
+			case SEK_REG_A4:
+				return SekC68KCurrentContext->A[4];
+			case SEK_REG_A5:
+				return SekC68KCurrentContext->A[5];
+			case SEK_REG_A6:
+				return SekC68KCurrentContext->A[6];
+			case SEK_REG_A7:
+				return SekC68KCurrentContext->A[7];
 
-		default:
-			break;
-	}
+			case SEK_REG_PC:
+				return SekC68KCurrentContext->PC - SekC68KCurrentContext->BasePC;
 
-   return FALSE;
+			case SEK_REG_SR:
+				return 0;
+
+			case SEK_REG_SP:
+				return SekC68KCurrentContext->A[7];
+			case SEK_REG_USP:
+				return SekC68KCurrentContext->USP;
+			case SEK_REG_ISP:
+				return 0;
+
+			case SEK_REG_CCR:
+				return (SekC68KCurrentContext->flag_X << 4) |
+					(SekC68KCurrentContext->flag_N << 3) |
+					(SekC68KCurrentContext->flag_Z << 2) |
+					(SekC68KCurrentContext->flag_V << 1) |
+					(SekC68KCurrentContext->flag_C << 0);
+
+			default:
+				return 0;
+		}
+	}
 #else
-	return FALSE;
+	return 0;
 #endif
 }
 
+BOOL SekDbgSetRegister(enum SekRegister nRegister, UINT32 nValue)
+{
+	return FALSE;
+}
+
 // ----------------------------------------------------------------------------
 // Savestate support
 
@@ -2122,72 +1978,65 @@ INT32 SekScan(INT32 nAction)
 	// Scan the 68000 states
 	struct BurnArea ba;
 
-	if ((nAction & ACB_DRIVER_DATA) == 0) {
+	if ((nAction & ACB_DRIVER_DATA) == 0)
 		return 1;
-	}
 
 	memset(&ba, 0, sizeof(ba));
 
-	for (INT32 i = 0; i <= nSekCount; i++) {
+	for (INT32 i = 0; i <= nSekCount; i++)
+   {
 		char szName[] = "MC68000 #n";
-#if defined EMU_A68K && defined EMU_M68K
 		INT32 nType = nSekCPUType[i];
-#endif
 
 		szName[9] = '0' + i;
 
 		SCAN_VAR(nSekCPUType[i]);
-
-#if defined EMU_A68K && defined EMU_M68K
-		// Switch to another core if needed
-		if ((nAction & ACB_WRITE) && nType != nSekCPUType[i]) {
-			if (nType != 0 && nType != 0x68000 && nSekCPUType[i] != 0 && nSekCPUType[i] != 0x68000) {
-				continue;
-			}
-
-			if (nSekCPUType[i] == 0x68000) {
-				SekCPUExitA68K(i);
-				if (SekInitCPUM68K(i, 0x68000)) {
-					return 1;
-				}
-			} else {
-				SekCPUExitM68K(i);
-				if (SekInitCPUA68K(i, 0x68000)) {
-					return 1;
-				}
-			}
-		}
-#endif
+		SCAN_VAR(nSekIRQPending[i]); // fix for Gradius 2 s.states -dink feb.3.2015
 
 #ifdef EMU_A68K
-		if (nSekCPUType[i] == 0) {
-			ba.Data = SekRegs[i];
-			ba.nLen = sizeof(A68KContext);
-			ba.szName = szName;
-
-			if (nAction & ACB_READ) {
-				// Blank pointers
-				SekRegs[i]->IrqCallback = NULL;
-				SekRegs[i]->ResetCallback = NULL;
-			}
-
-			BurnAcb(&ba);
+      if(nSekCpuCore == SEK_CORE_A68K)
+      {
+         if (nSekCPUType[i] == 0) {
+            ba.Data = SekRegs[i];
+            ba.nLen = sizeof(A68KContext);
+            ba.szName = szName;
+
+            if (nAction & ACB_READ) {
+               // Blank pointers
+               SekRegs[i]->IrqCallback = NULL;
+               SekRegs[i]->ResetCallback = NULL;
+            }
+
+            BurnAcb(&ba);
+
+            // Restore pc
+            A68KChangePC(SekRegs[i]->pc);
+            // Re-setup each cpu on read/write
+            if (nAction & ACB_ACCESSMASK) {
+               SekSetup(SekRegs[i]);
+            }
+         }
+      }
+#endif
 
-			// Re-setup each cpu on read/write
-			if (nAction & ACB_ACCESSMASK) {
-				SekSetup(SekRegs[i]);
-			}
-		} else {
+#ifdef EMU_M68K
+      if(nSekCpuCore == SEK_CORE_M68K)
+      {
+         if (nSekCPUType[i] != 0)
+         {
+            ba.Data = SekM68KContext[i];
+            // for savestate portability: preserve our cpu's pointers, they are set up in DrvInit() and can be specific to different systems.
+            // Therefore we scan the cpu context structure up until right before the pointers
+            ba.nLen = m68k_context_size_no_pointers();
+            ba.szName = szName;
+            BurnAcb(&ba);
+         }
+      }
 #endif
 
-#if defined(EMU_M68K)
-			if (nSekCPUType[i] != 0) {
-				ba.Data = SekM68KContext[i];
-				ba.nLen = nSekM68KContextSize[i];
-				ba.szName = szName;
-				BurnAcb(&ba);
-			}
-#elif defined(EMU_C68K)
+#ifdef EMU_C68K
+      if(nSekCpuCore == SEK_CORE_C68K)
+      {
          // PC must contain regular m68000 value
          SekC68KContext[i]->PC -= SekC68KContext[i]->BasePC;
 
@@ -2199,12 +2048,8 @@ INT32 SekScan(INT32 nAction)
          // restore pointer in PC
          SekC68KContext[i]->BasePC = (UINT32)FIND_F(SekC68KContext[i]->PC) - (SekC68KContext[i]->PC & ~SEK_PAGEM);
          SekC68KContext[i]->PC += SekC68KContext[i]->BasePC;
+      }
 #endif
-
-#ifdef EMU_A68K
-		}
-#endif
-
 	}
 
 	return 0;
diff --git a/src/cpu/m68000_intf.h b/src/cpu/m68000_intf.h
index 972de2c..495c3b3 100644
--- a/src/cpu/m68000_intf.h
+++ b/src/cpu/m68000_intf.h
@@ -5,28 +5,30 @@
 extern "C" {
 #endif
 
-#ifndef FASTCALL
- #undef __fastcall
- #define __fastcall
-#endif
-
 #if defined BUILD_A68K
  #define EMU_A68K								// Use A68K Assembler 68000 emulator
 #endif
 
-//#define EMU_M68K								// Use Musashi 68000 emulator
-//#define EMU_C68K
+#ifdef BUILD_C68K
+ #define EMU_C68K
+ #include "c68k/c68k.h"
+#endif
 
-#define SEK_MAX	(4)								// Maximum number of CPUs supported
+#ifdef BUILD_M68K
+ #define EMU_M68K
+ #include "m68k/m68k.h"
+#endif
 
-#if defined EMU_M68K
-#include "m68k/m68k.h"
+#ifndef M68K_INT_ACK_AUTOVECTOR // if musashi core is completely disabled
+ #define M68K_INT_ACK_AUTOVECTOR 0xffffffff
 #endif
 
-#if defined EMU_C68K
-#include "c68k/c68k.h"
+#ifndef m68k_set_reg
+ #define m68k_set_reg(A, B) 
 #endif
 
+#define SEK_MAX	(4)								// Maximum number of CPUs supported
+
 // Number of bits used for each page in the fast memory map
 #define SEK_BITS		(10)					// 10 = 0x0400 page size
 #define SEK_PAGE_COUNT  (1 << (24 - SEK_BITS))	// Number of pages
@@ -42,57 +44,53 @@ extern "C" {
 #endif
 
 #ifdef EMU_A68K
-void __cdecl M68000_RUN(void);
-void __cdecl M68000_RESET(void);
-#endif
-
-#ifdef EMU_A68K
- // The format of the data in a68k.asm (at the _M68000_regs location)
- struct A68KContext {
-	UINT32 d[8], a[8];
-	UINT32 isp, srh, ccr, xc, pc, irq, sr;
-	INT32 (*IrqCallback) (INT32 nIrq);
-	UINT32 ppc;
-	INT32 (*ResetCallback)();
-	INT32 (*RTECallback)();
-	INT32 (*CmpCallback)(UINT32 val, INT32 reg);
-	UINT32 sfc, dfc, usp, vbr;
-	UINT32 nAsmBank, nCpuVersion;
- };
- struct A68KContext M68000_regs;
- extern     struct A68KContext* SekRegs[SEK_MAX];
-
- UINT8* OP_ROM;
- UINT8* OP_RAM;
-
- void __fastcall AsekChangePc(UINT32 pc);
+   void  M68000_RUN(void);
+   void  M68000_RESET(void);
+
+   // The format of the data in a68k.asm (at the _M68000_regs location)
+   struct A68KContext {
+      UINT32 d[8], a[8];
+      UINT32 isp, srh, ccr, xc, pc, irq, sr;
+      INT32 (*IrqCallback) (INT32 nIrq);
+      UINT32 ppc;
+      INT32 (*ResetCallback)();
+      INT32 (*RTECallback)();
+      INT32 (*CmpCallback)(UINT32 val, INT32 reg);
+      UINT32 sfc, dfc, usp, vbr;
+      UINT32 nAsmBank, nCpuVersion;
+   };
+   struct A68KContext M68000_regs;
+   extern     struct A68KContext* SekRegs[SEK_MAX];
+
+   UINT8* OP_ROM;
+   UINT8* OP_RAM;
+
+   void  AsekChangePc(UINT32 pc);
 #endif
 
 #ifdef EMU_M68K
- INT32 nSekM68KContextSize[SEK_MAX];
- INT8* SekM68KContext[SEK_MAX];
- INT32 m68k_ICount;
+   INT32 nSekM68KContextSize[SEK_MAX];
+   INT8* SekM68KContext[SEK_MAX];
+   INT32 m68k_ICount;
 #endif
 
-
 #ifdef EMU_C68K
- c68k_struc * SekC68KCurrentContext;
- c68k_struc * SekC68KContext[SEK_MAX]; 
+   c68k_struc * SekC68KCurrentContext;
+   c68k_struc * SekC68KContext[SEK_MAX]; 
 #define c68k_ICount	(SekC68KCurrentContext->ICount)
 #endif
 
+typedef UINT8 ( *pSekReadByteHandler)(UINT32 a);
+typedef void ( *pSekWriteByteHandler)(UINT32 a, UINT8 d);
+typedef UINT16 ( *pSekReadWordHandler)(UINT32 a);
+typedef void ( *pSekWriteWordHandler)(UINT32 a, UINT16 d);
+typedef UINT32 ( *pSekReadLongHandler)(UINT32 a);
+typedef void ( *pSekWriteLongHandler)(UINT32 a, UINT32 d);
 
-typedef UINT8 (__fastcall *pSekReadByteHandler)(UINT32 a);
-typedef void (__fastcall *pSekWriteByteHandler)(UINT32 a, UINT8 d);
-typedef UINT16 (__fastcall *pSekReadWordHandler)(UINT32 a);
-typedef void (__fastcall *pSekWriteWordHandler)(UINT32 a, UINT16 d);
-typedef UINT32 (__fastcall *pSekReadLongHandler)(UINT32 a);
-typedef void (__fastcall *pSekWriteLongHandler)(UINT32 a, UINT32 d);
-
-typedef INT32 (__fastcall *pSekResetCallback)();
-typedef INT32 (__fastcall *pSekRTECallback)();
-typedef INT32 (__fastcall *pSekIrqCallback)(INT32 irq);
-typedef INT32 (__fastcall *pSekCmpCallback)(UINT32 val, INT32 reg);
+typedef INT32 ( *pSekResetCallback)();
+typedef INT32 ( *pSekRTECallback)();
+typedef INT32 ( *pSekIrqCallback)(INT32 irq);
+typedef INT32 ( *pSekCmpCallback)(UINT32 val, INT32 reg);
 
 extern INT32 nSekCycles[SEK_MAX], nSekCPUType[SEK_MAX];
 
@@ -121,6 +119,13 @@ struct SekExt {
 #define SEK_DEF_READ_LONG(i, a) { UINT32 d; d = pSekExt->ReadWord[i](a) << 16; d |= pSekExt->ReadWord[i]((a) + 2); return d; }
 #define SEK_DEF_WRITE_LONG(i, a, d) { pSekExt->WriteWord[i]((a),(UINT16)((d) >> 16)); pSekExt->WriteWord[i]((a) + 2,(UINT16)((d) & 0xffff)); }
 
+#define SEK_CORE_A68K (2)
+#define SEK_CORE_M68K (1)
+#define SEK_CORE_C68K (0)
+
+extern INT32 nSekCpuCore; // 0 - c68k, 1 - m68k, 2 - a68k
+extern INT32 DebugStep; // 0 - off, 1 - on
+
 extern struct SekExt *SekExt[SEK_MAX], *pSekExt;
 extern INT32 nSekActive;										// The cpu which is currently being emulated
 extern INT32 nSekCyclesTotal, nSekCyclesScanline, nSekCyclesSegment, nSekCyclesDone, nSekCyclesToDo;
@@ -169,40 +174,28 @@ inline static INT32 SekIdle(INT32 nCycles)
 	return nCycles;
 }
 
-inline static INT32 SekSegmentCycles()
+static inline INT32 SekSegmentCycles(void)
 {
-#if defined(EMU_M68K)
-	return nSekCyclesDone + nSekCyclesToDo - m68k_ICount;
-#elif defined(EMU_C68K)
-   return nSekCyclesDone + nSekCyclesToDo - c68k_ICount;
-#else
-	return nSekCyclesDone + nSekCyclesToDo;
+#if defined(EMU_A68K) || defined(EMU_M68K)
+	if(nSekCpuCore == SEK_CORE_A68K || nSekCpuCore == SEK_CORE_M68K) return nSekCyclesDone + nSekCyclesToDo - m68k_ICount;
+#endif
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K) return nSekCyclesDone + nSekCyclesToDo - c68k_ICount;
 #endif
 }
 
-#if defined FBA_DEBUG
-static INT32 SekTotalCycles()
-#else
-inline static INT32 SekTotalCycles()
-#endif
+static inline INT32 SekTotalCycles(void)
 {
-#if defined(EMU_M68K)
-	return nSekCyclesTotal + nSekCyclesToDo - m68k_ICount;
-#elif defined(EMU_C68K)
-   return nSekCyclesTotal + nSekCyclesToDo - c68k_ICount;
-#else
-	return nSekCyclesTotal + nSekCyclesToDo;
+#if defined(EMU_A68K) || defined(EMU_M68K)
+	if(nSekCpuCore == SEK_CORE_A68K || nSekCpuCore == SEK_CORE_M68K) return nSekCyclesTotal + nSekCyclesToDo - m68k_ICount;
+#endif
+#ifdef EMU_C68K
+	if(nSekCpuCore == SEK_CORE_C68K) return nSekCyclesTotal + nSekCyclesToDo - c68k_ICount;
 #endif
 }
 
 inline static INT32 SekCurrentScanline()
 {
-#if defined FBA_DEBUG
-	extern UINT8 DebugCPU_SekInitted;
-	if (!DebugCPU_SekInitted) bprintf(PRINT_ERROR, (TCHAR*)_T("SekCurrentScanline called without init\n"));
-	if (nSekActive == -1) bprintf(PRINT_ERROR, (TCHAR*)_T("SekCurrentScanline called when no CPU open\n"));
-#endif
-
 	return SekTotalCycles() / nSekCyclesScanline;
 }
 
diff --git a/src/cpu/m68k/m68kfpu.c b/src/cpu/m68k/m68kfpu.c
index a424c38..e7f961c 100644
--- a/src/cpu/m68k/m68kfpu.c
+++ b/src/cpu/m68k/m68kfpu.c
@@ -1,32 +1,34 @@
 #define fatalerror	printf
 
+#include <stdint.h>
+
 #define FPCC_N			0x08000000
 #define FPCC_Z			0x04000000
 #define FPCC_I			0x02000000
 #define FPCC_NAN		0x01000000
 
-#define DOUBLE_INFINITY					U64(0x7ff0000000000000)
-#define DOUBLE_EXPONENT					U64(0x7ff0000000000000)
-#define DOUBLE_MANTISSA					U64(0x000fffffffffffff)
+#define DOUBLE_INFINITY					UINT64_C(0x7ff0000000000000)
+#define DOUBLE_EXPONENT					UINT64_C(0x7ff0000000000000)
+#define DOUBLE_MANTISSA					UINT64_C(0x000fffffffffffff)
 
 INLINE void SET_CONDITION_CODES(fp_reg reg)
 {
 	REG_FPSR &= ~(FPCC_N|FPCC_Z|FPCC_I|FPCC_NAN);
 
 	// sign flag
-	if (reg.i & U64(0x8000000000000000))
+	if (reg.i & UINT64_C(0x8000000000000000))
 	{
 		REG_FPSR |= FPCC_N;
 	}
 
 	// zero flag
-	if ((reg.i & U64(0x7fffffffffffffff)) == 0)
+	if ((reg.i & UINT64_C(0x7fffffffffffffff)) == 0)
 	{
 		REG_FPSR |= FPCC_Z;
 	}
 
 	// infinity flag
-	if ((reg.i & U64(0x7fffffffffffffff)) == DOUBLE_INFINITY)
+	if ((reg.i & UINT64_C(0x7fffffffffffffff)) == DOUBLE_INFINITY)
 	{
 		REG_FPSR |= FPCC_I;
 	}
